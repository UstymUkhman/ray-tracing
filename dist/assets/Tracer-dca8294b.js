import{V as r,r as D,d as L,C as p,t as g}from"./worker-a40d7360.js";class T{t=0;frontFace=!1;material;point=new r;normal=new r;copy(t){this.frontFace=t.frontFace,this.normal.copy(t.normal),this.point.copy(t.point),this.t=t.t}setFaceNormal(t,e){this.frontFace=t.direction.dot(e)<0,this.normal.copy(this.frontFace?e:e.negate)}}var m=new T;class R{}class q extends R{objects=[];constructor(){super()}add(t){this.objects.push(t)}hit(t,e,i,o){let s=!1,n=i;for(let a=0,l=this.objects.length;a<l;a++)this.objects[a].hit(t,e,n,m)&&(n=m.t,o.copy(m),s=!0);return s}clear(){this.objects.length=0}}class b{}class v extends b{fuzz;albedo;direction=new r;constructor(t,e){super(),this.albedo=t.clone,this.fuzz=Math.min(e,1)}scatter(t,e,i,o){const s=t.direction.unitVector.reflect(e.normal);return this.direction.randomUnitSphere.multiply(this.fuzz).add(s),i.direction=this.direction,i.origin=e.point,o.copy(this.albedo),this.direction.dot(e.normal)>0}}class y extends b{albedo;direction=new r;constructor(t){super(),this.albedo=t.clone}scatter(t,e,i,o){const s=e.normal.add(this.direction.randomUnitVector);return s.nearZero&&s.copy(e.normal),i.direction=s,i.origin=e.point,o.copy(this.albedo),!0}}class z extends b{constructor(t){super(),this.refraction=t}reflectance(t,e){const i=Math.pow((1-e)/(1+e),2);return Math.pow(1-t,5)*(1-i)+i}scatter(t,e,i,o){const s=t.direction.unitVector,n=Math.min(s.clone.negate.dot(e.normal),1),a=e.frontFace?1/this.refraction:this.refraction;return Math.sqrt(1-n*n)*a>1||Math.random()<this.reflectance(n,a)?s.reflect(e.normal):s.refract(e.normal,a),i.direction=s,i.origin=e.point,o.reset(1),!0}}class P{hittables=new q;color=new r;constructor(){this.addSphere(1e3,new r(0,-1e3,0),new y(new r(.5))),this.generateSmallSpheres(),this.addSphere(1,new r(0,1,0),new z(1.5)),this.addSphere(1,new r(-4,1,0),new y(new r(.4,.2,.1))),this.addSphere(1,new r(4,1,0),new v(new r(.7,.6,.5),0))}addSphere(t,e,i){this.hittables.add(new I(t,e,i))}generateSmallSpheres(){for(let t=-11;t<11;t++)for(let e=-11;e<11;e++){const i=new r(Math.random()*.9+t,.2,Math.random()*.9+e),o=new r(4,.2,0);if(i.clone.sub(o).length>.9){const s=Math.random();if(s<.8){this.color.random().multiply(this.color.random());const n=new y(this.color);this.addSphere(.2,i,n)}else if(s<.95){this.color.random(.5);const n=D(0,.5),a=new v(this.color,n);this.addSphere(.2,i,a)}else{const n=new z(1.5);this.addSphere(.2,i,n)}}}}get objects(){return this.hittables}}class I extends R{constructor(t,e,i){super(),this.radius=t,this.center=e,this.material=i}hit(t,e,i,o){const s=t.origin.clone.sub(this.center),n=t.direction.lengthSquared,a=s.dot(t.direction),l=s.lengthSquared-this.radius*this.radius,u=a*a-n*l;if(u<0)return!1;const d=Math.sqrt(u);let h=(-a-d)/n;if((h<e||h>i)&&(h=(-a+d)/n,h<e||h>i))return!1;o.t=h,o.point.copy(t.at(o.t));const w=o.point.clone.sub(this.center).divide(this.radius);return o.setFaceNormal(t,w),o.material=this.material,!0}}class U{u;v;width;height;origin;vertical;lensRadius;horizontal;random=new r;lowerLeftCorner;constructor(t,e,i,o,s,n,a){const l=t.clone.sub(e).unitVector,u=Math.tan(L(o)*.5);this.u=i.cross(l).unitVector,this.v=l.clone.cross(this.u),this.origin=t,this.height=u*2,this.width=s*this.height,this.lensRadius=n*.5,this.horizontal=this.u.clone.multiply(this.width).multiply(a),this.vertical=this.v.clone.multiply(this.height).multiply(a),this.lowerLeftCorner=this.origin.clone.sub(this.horizontal.clone.divide(2)).sub(this.vertical.clone.divide(2)).sub(l.multiply(a))}setRay(t,e,i){const o=this.random.randomUnitDisk.multiply(this.lensRadius),s=this.u.clone.multiply(o.x).add(this.v.clone.multiply(o.y));t.direction=this.lowerLeftCorner.clone.add(this.horizontal.clone.multiply(e)).add(this.vertical.clone.multiply(i)).sub(this.origin).sub(s),t.origin=s.add(this.origin)}}class M{constructor(t=new r,e=new r){this.orig=t,this.dir=e}color=new r(1);far=1/0;near=.001;at(t){return this.orig.clone.add(this.dir.clone.multiply(t))}getColor(t,e,i){if(!i)return this.color.reset();if(e.hit(t,this.near,this.far,m)){const s=new r,n=new M;return m.material.scatter(t,m,n,s)?this.getColor(n,e,i-1).multiply(s):this.color.reset()}const o=(t.dir.unitVector.y+1)*.5;return this.color.reset(1).multiply(1-o).add(new r(.5,.7,1).multiply(o))}set direction(t){this.dir.copy(t)}get direction(){return this.dir}set origin(t){this.orig.copy(t)}get origin(){return this.orig}}class k{last=Date.now();camera;world=new P;color=new r;width=p.width;height=p.height;depth=p.maxDepth;samples=p.samples;constructor(){const t=this.width/this.height;this.camera=new U(new r(13,2,3),new r(0,0,0),new r(0,1,0),20,t,.1,10)}createPPMImage(t,e,i){const o=new M,s=this.samples===e;for(let d=0,h=this.height,w=this.width-1,S=h-1;h--;){s&&console.info(`Progress: ${g((1-h/S)*100)}%`);for(let f=0;f<this.width;f++,d+=3){this.color.set(t[d],t[d+1],t[d+2]);const x=(f+Math.random())/w,F=(h+Math.random())/S;this.camera.setRay(o,x,F);const{x:$,y:j,z:V}=this.color.add(o.getColor(o,this.world.objects,this.depth));t[d]=$,t[d+1]=j,t[d+2]=V}}const n=Date.now(),a=`${s&&"Total "||""}Samples: ${e}`,l=`Total Time: ${g((n-i)/1e3)} sec.`,u=`Last Render Time: ${g((n-this.last)/1e3)} sec.`;return console.info(`${a} | ${u} | ${l}`),this.last=n,t}}const C=new k;function H(c,t,e=C.samples){return C.createPPMImage(t,e,c)}export{H as trace};
